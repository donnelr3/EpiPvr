edges,
conHull,
ordered_midpoints1_df,
ordered_midpoints2_df,
centroids)
ggplot(pointsout, aes(x = x, y = y, color = factor(cluster))) +
geom_point(size = 1.5) +
geom_segment(data = edges, aes(x = x1, y = y1, xend = x2, yend = y2, color = border),color='lightgray', size = 0.5) + # Borders
geom_polygon(data =  conHull, aes(x = xhull, y = yhull),fill=NA,color='navy',size = 1) + # Borders
geom_path(data =  ordered_midpoints1_df, aes(x = Ix, y = Iy),color='black',size = 1) + # Borders
geom_path(data =  ordered_midpoints2_df, aes(x = Ix, y = Iy),color='black',size = 1) + # Borders
theme_minimal() +
coord_equal() +
labs(color = "Country")
simulate_region_nodes <- function(nC,total_nodes = 100,cluster_weights = NULL,center_spread = 5,sd_range = c(0.3, 0.7)) {
# Default: random equal weights
if (is.null(cluster_weights)) {
nodes_per_cluster <- rmultinom(n=1,size=total_nodes, prob=rep(1 /nC, nC))
} else {
nodes_per_cluster <- rmultinom(n=1,size=total_nodes, prob=cluster_weights/sum(cluster_weights))
}
# Generate random cluster centers
centers <- matrix(runif(nC * 2, -center_spread, center_spread), ncol = 2)
# Generate per-axis standard deviations for each cluster
sds_x <- runif(nC, sd_range[1], sd_range[2])
sds_y <- runif(nC, sd_range[1], sd_range[2])
# Sample points
all_points <- do.call(rbind, lapply(1:nC, function(i) {
n_i <- nodes_per_cluster[i]
mu_x <- centers[i, 1]
mu_y <- centers[i, 2]
x_vals <- rnorm(n_i, mean = mu_x, sd = sds_x[i])
y_vals <- rnorm(n_i, mean = mu_y, sd = sds_y[i])
data.frame(x = x_vals, y = y_vals, cluster = i, mux = mu_x, muy = mu_y)
}))
# random rotation of groups
theta <- runif(1, 0, 2 * pi)
R <- matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2)
rotated_all_points <- as.matrix(all_points[,c(1,2)]) %*% R
# Translate to cluster center
rotated_all_points[,1] <- rotated_all_points[,1] + all_points$mux
rotated_all_points[,2] <- rotated_all_points[,2] + all_points$muy
list(rotpoints = cbind(rotated_all_points,all_points$cluster), centers = centers, sds_x = sds_x, sds_y = sds_y, weights = cluster_weights)
}
n_points <- 100
n_countries <- 3
points_list=simulate_region_nodes(n_countries,cluster_weights = c(10,20,50),total_nodes=n_points,center_spread = 2,sd_range = c(0.5, 2))
# FUNCTIONS to match within a threshold difference #######
fselect_in <- function(x, ref, d = 2){
round(x, digits=d) %in% round(ref, digits=d)
}
# Function to find the nearest neighbor
find_nearest <- function(current, points) {
distances <- sqrt((points$Ix - current$Ix)^2 + (points$Iy - current$Iy)^2)
nearest_idx <- which.min(distances)
return(nearest_idx)
}
pointsout=as.data.frame(points_list$rotpoints)
names(pointsout)=c('x','y','cluster')
#ggplot(pointsout, aes(x = x, y = y, color = factor(cluster))) +
#  geom_point(size = 1.5) +
#  theme_minimal() +
#  coord_equal() +
#  labs(color = "Country")
# CLUSTER INTO COUNTRIES
kmeans_result <- kmeans(pointsout[, c("x", "y")], centers = n_countries)
pointsout=pointsout[,-3]
pointsout$cluster=kmeans_result$cluster
centroids <- kmeans_result$centers
# Compute DELAUNEY triangulation
tri <- deldir(pointsout$x, pointsout$y)
edges <- tri$delsgs # Get triangulation edges
fledges <- tri$dirsgs # Get triangulation edges
# Regional external border ###############
hull_inds=chull(pointsout$x,pointsout$y)
xhull=pointsout$x[hull_inds]
yhull=pointsout$y[hull_inds]
conHull=cbind(xhull,yhull)
clus=numeric(0)
for (kk in 1:dim(conHull)[1]) {
indvec=(pointsout$x+pointsout$y)==sum(conHull[kk,])
clus=c(clus,pointsout[indvec,]$cluster)
}
conHull=cbind(conHull,clus)
#########################################
# Country external borders ###############
points_cluster1=as.matrix(pointsout[pointsout$cluster==1,1:2])
points_cluster_list=list(points_cluster1)
edges$cluster1[fselect_in(edges$x1 + edges$y1, rowSums(points_cluster_list[[1]]))==TRUE] <- 1
edges$cluster2[fselect_in(edges$x2 + edges$y2, rowSums(points_cluster_list[[1]]))==TRUE] <- 1
for (jj in 2:n_countries) {
print(paste("early iteration is ",jj))
points_cluster_list[[jj]]=as.matrix(pointsout[pointsout$cluster==jj,1:2])
edges$cluster1[fselect_in(edges$x1 + edges$y1, rowSums(points_cluster_list[[jj]]))==TRUE] <- jj
edges$cluster2[fselect_in(edges$x2 + edges$y2, rowSums(points_cluster_list[[jj]]))==TRUE] <- jj
}
edges$border <- edges$cluster1 != edges$cluster2 # Borders where clusters differ
#########################################
################# find the edges on the border and then calculate their midpoints (from which we draw borders between countries)
intersections=edges[edges$border==TRUE,]
intersections$Ix=(intersections$x1+intersections$x2)/2
intersections$Iy=(intersections$y1+intersections$y2)/2
#########################################
################# Now order the midpoints so you dont craxy jagged lines!
################# FOCUS first on all borders with country 1
# strategy is to join up the mid points via nearest neightbors but important to start from edge case
intersections1=rbind(intersections[intersections$cluster1==1,],intersections[intersections$cluster2==1,])
# Start with a random midpoint
ordered_midpoints1 <- list(intersections1[match(max(intersections1$Iy),intersections1$Iy), ])
# Iteratively find the nearest neighbor
remaining_points <- intersections1[-match(max(intersections1$Iy),intersections1$Iy), ]
iter=0
while (nrow(remaining_points) > 0) {
iter=iter+1
print(paste('iteration is', iter))
current_point <- ordered_midpoints1[[length(ordered_midpoints1)]]
nearest_idx <- find_nearest(current_point, remaining_points)
ordered_midpoints1 <- append(ordered_midpoints1, list(remaining_points[nearest_idx, ]))
remaining_points <- remaining_points[-nearest_idx, ]
}
ordered_midpoints1_df=do.call(rbind, ordered_midpoints1)
################# REPEAT on all borders with country 2
# strategy is to join up the mid points via nearest neighbors but important to start from edge case (ymin)
intersections2=rbind(intersections[intersections$cluster1==2,],intersections[intersections$cluster2==2,])
# Start with a random midpoint TO HOLD
held <- list(intersections2[match(min(intersections2$Iy),intersections2$Iy), ])
unheld=intersections2[-match(min(intersections2$Iy),intersections2$Iy), ]
ordered_midpoints2 <- list(unheld[match(min(unheld$Ix),unheld$Ix), ])
# Iteratively find the nearest neighbor
remaining_points <- intersections2[-match(min(unheld$Ix),unheld$Ix), ]
iter=0
while (nrow(remaining_points) > 0) {
iter=iter+1
print(paste('iteration is', iter))
current_point <- ordered_midpoints2[[length(ordered_midpoints2)]]
nearest_idx <- find_nearest(current_point, remaining_points)
ordered_midpoints2 <- append(ordered_midpoints2, list(remaining_points[nearest_idx, ]))
remaining_points <- remaining_points[-nearest_idx, ]
}
ordered_midpoints2_df=do.call(rbind, ordered_midpoints2)
ordered_midpoints2_df=ordered_midpoints2_df[-nrow(ordered_midpoints2_df), ]
#########################################
lout=list(pointsout,
edges,
conHull,
ordered_midpoints1_df,
ordered_midpoints2_df,
centroids)
ggplot(pointsout, aes(x = x, y = y, color = factor(cluster))) +
geom_point(size = 1.5) +
geom_segment(data = edges, aes(x = x1, y = y1, xend = x2, yend = y2, color = border),color='lightgray', size = 0.5) + # Borders
geom_polygon(data =  conHull, aes(x = xhull, y = yhull),fill=NA,color='navy',size = 1) + # Borders
geom_path(data =  ordered_midpoints1_df, aes(x = Ix, y = Iy),color='black',size = 1) + # Borders
geom_path(data =  ordered_midpoints2_df, aes(x = Ix, y = Iy),color='black',size = 1) + # Borders
theme_minimal() +
coord_equal() +
labs(color = "Country")
simulate_region_nodes <- function(nC,total_nodes = 100,cluster_weights = NULL,center_spread = 5,sd_range = c(0.3, 0.7)) {
# Default: random equal weights
if (is.null(cluster_weights)) {
nodes_per_cluster <- rmultinom(n=1,size=total_nodes, prob=rep(1 /nC, nC))
} else {
nodes_per_cluster <- rmultinom(n=1,size=total_nodes, prob=cluster_weights/sum(cluster_weights))
}
# Generate random cluster centers
centers <- matrix(runif(nC * 2, -center_spread, center_spread), ncol = 2)
# Generate per-axis standard deviations for each cluster
sds_x <- runif(nC, sd_range[1], sd_range[2])
sds_y <- runif(nC, sd_range[1], sd_range[2])
# Sample points
all_points <- do.call(rbind, lapply(1:nC, function(i) {
n_i <- nodes_per_cluster[i]
mu_x <- centers[i, 1]
mu_y <- centers[i, 2]
x_vals <- rnorm(n_i, mean = mu_x, sd = sds_x[i])
y_vals <- rnorm(n_i, mean = mu_y, sd = sds_y[i])
data.frame(x = x_vals, y = y_vals, cluster = i, mux = mu_x, muy = mu_y)
}))
# random rotation of groups
theta <- runif(1, 0, 2 * pi)
R <- matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2)
rotated_all_points <- as.matrix(all_points[,c(1,2)]) %*% R
# Translate to cluster center
rotated_all_points[,1] <- rotated_all_points[,1] + all_points$mux
rotated_all_points[,2] <- rotated_all_points[,2] + all_points$muy
list(rotpoints = cbind(rotated_all_points,all_points$cluster), centers = centers, sds_x = sds_x, sds_y = sds_y, weights = cluster_weights)
}
n_points <- 100
n_countries <- 3
points_list=simulate_region_nodes(n_countries,cluster_weights = c(10,20,50),total_nodes=n_points,center_spread = 2,sd_range = c(0.5, 2))
# FUNCTIONS to match within a threshold difference #######
fselect_in <- function(x, ref, d = 2){
round(x, digits=d) %in% round(ref, digits=d)
}
# Function to find the nearest neighbor
find_nearest <- function(current, points) {
distances <- sqrt((points$Ix - current$Ix)^2 + (points$Iy - current$Iy)^2)
nearest_idx <- which.min(distances)
return(nearest_idx)
}
pointsout=as.data.frame(points_list$rotpoints)
names(pointsout)=c('x','y','cluster')
#ggplot(pointsout, aes(x = x, y = y, color = factor(cluster))) +
#  geom_point(size = 1.5) +
#  theme_minimal() +
#  coord_equal() +
#  labs(color = "Country")
# CLUSTER INTO COUNTRIES
kmeans_result <- kmeans(pointsout[, c("x", "y")], centers = n_countries)
pointsout=pointsout[,-3]
pointsout$cluster=kmeans_result$cluster
centroids <- kmeans_result$centers
# Compute DELAUNEY triangulation
tri <- deldir(pointsout$x, pointsout$y)
edges <- tri$delsgs # Get triangulation edges
fledges <- tri$dirsgs # Get triangulation edges
# Regional external border ###############
hull_inds=chull(pointsout$x,pointsout$y)
xhull=pointsout$x[hull_inds]
yhull=pointsout$y[hull_inds]
conHull=cbind(xhull,yhull)
clus=numeric(0)
for (kk in 1:dim(conHull)[1]) {
indvec=(pointsout$x+pointsout$y)==sum(conHull[kk,])
clus=c(clus,pointsout[indvec,]$cluster)
}
conHull=cbind(conHull,clus)
#########################################
# Country external borders ###############
points_cluster1=as.matrix(pointsout[pointsout$cluster==1,1:2])
points_cluster_list=list(points_cluster1)
edges$cluster1[fselect_in(edges$x1 + edges$y1, rowSums(points_cluster_list[[1]]))==TRUE] <- 1
edges$cluster2[fselect_in(edges$x2 + edges$y2, rowSums(points_cluster_list[[1]]))==TRUE] <- 1
for (jj in 2:n_countries) {
print(paste("early iteration is ",jj))
points_cluster_list[[jj]]=as.matrix(pointsout[pointsout$cluster==jj,1:2])
edges$cluster1[fselect_in(edges$x1 + edges$y1, rowSums(points_cluster_list[[jj]]))==TRUE] <- jj
edges$cluster2[fselect_in(edges$x2 + edges$y2, rowSums(points_cluster_list[[jj]]))==TRUE] <- jj
}
edges$border <- edges$cluster1 != edges$cluster2 # Borders where clusters differ
#########################################
################# find the edges on the border and then calculate their midpoints (from which we draw borders between countries)
intersections=edges[edges$border==TRUE,]
intersections$Ix=(intersections$x1+intersections$x2)/2
intersections$Iy=(intersections$y1+intersections$y2)/2
#########################################
################# Now order the midpoints so you dont craxy jagged lines!
################# FOCUS first on all borders with country 1
# strategy is to join up the mid points via nearest neightbors but important to start from edge case
intersections1=rbind(intersections[intersections$cluster1==1,],intersections[intersections$cluster2==1,])
# Start with a random midpoint
ordered_midpoints1 <- list(intersections1[match(max(intersections1$Iy),intersections1$Iy), ])
# Iteratively find the nearest neighbor
remaining_points <- intersections1[-match(max(intersections1$Iy),intersections1$Iy), ]
iter=0
while (nrow(remaining_points) > 0) {
iter=iter+1
print(paste('iteration is', iter))
current_point <- ordered_midpoints1[[length(ordered_midpoints1)]]
nearest_idx <- find_nearest(current_point, remaining_points)
ordered_midpoints1 <- append(ordered_midpoints1, list(remaining_points[nearest_idx, ]))
remaining_points <- remaining_points[-nearest_idx, ]
}
ordered_midpoints1_df=do.call(rbind, ordered_midpoints1)
################# REPEAT on all borders with country 2
# strategy is to join up the mid points via nearest neighbors but important to start from edge case (ymin)
intersections2=rbind(intersections[intersections$cluster1==2,],intersections[intersections$cluster2==2,])
# Start with a random midpoint TO HOLD
held <- list(intersections2[match(min(intersections2$Iy),intersections2$Iy), ])
unheld=intersections2[-match(min(intersections2$Iy),intersections2$Iy), ]
ordered_midpoints2 <- list(unheld[match(min(unheld$Ix),unheld$Ix), ])
# Iteratively find the nearest neighbor
remaining_points <- intersections2[-match(min(unheld$Ix),unheld$Ix), ]
iter=0
while (nrow(remaining_points) > 0) {
iter=iter+1
print(paste('iteration is', iter))
current_point <- ordered_midpoints2[[length(ordered_midpoints2)]]
nearest_idx <- find_nearest(current_point, remaining_points)
ordered_midpoints2 <- append(ordered_midpoints2, list(remaining_points[nearest_idx, ]))
remaining_points <- remaining_points[-nearest_idx, ]
}
ordered_midpoints2_df=do.call(rbind, ordered_midpoints2)
ordered_midpoints2_df=ordered_midpoints2_df[-nrow(ordered_midpoints2_df), ]
#########################################
lout=list(pointsout,
edges,
conHull,
ordered_midpoints1_df,
ordered_midpoints2_df,
centroids)
ggplot(pointsout, aes(x = x, y = y, color = factor(cluster))) +
geom_point(size = 1.5) +
geom_segment(data = edges, aes(x = x1, y = y1, xend = x2, yend = y2, color = border),color='lightgray', size = 0.5) + # Borders
geom_polygon(data =  conHull, aes(x = xhull, y = yhull),fill=NA,color='navy',size = 1) + # Borders
geom_path(data =  ordered_midpoints1_df, aes(x = Ix, y = Iy),color='black',size = 1) + # Borders
geom_path(data =  ordered_midpoints2_df, aes(x = Ix, y = Iy),color='black',size = 1) + # Borders
theme_minimal() +
coord_equal() +
labs(color = "Country")
(10/12)*33
(2/12)*33
#load('.RData')
sysname <- Sys.info()[["sysname"]]
rm(list=setdiff(ls(), "sysname"))
if (sysname == "Windows") {
base_dir <- "C:/Users/ruair/Documents/Risk/R"
} else {
base_dir <- "~/Risk/R"
.libPaths(c("~/Rlibs", .libPaths()))
}
####################################                                 # FIRST HPC RUN
# Create your personal library folder (only needed once)
# dir.create("~/Rlibs", showWarnings = FALSE)
# Install a package into your personal lib
# install.packages("ggplot2", lib = "~/Rlibs")
###################################
args <- commandArgs(trailingOnly = TRUE)
batch_id <- as.integer(args[1])
library(deldir)
#library(cluster)
#library(networkD3)
#library(sampler)
library(ggplot2)
#library(officer)
library(magrittr)
library(gridExtra)
#library(grid)
library(lwgeom)
library(sf)
#library(gganimate)
library(dplyr)
#library(gifski)
library(data.table)
library(patchwork)
#library(ggsci)
#library(stats)
#library(pracma)
#library(utils)
#library(actuar)
source(file.path(base_dir, "populate_region.R"))
source(file.path(base_dir, "region_generator.R"))
source(file.path(base_dir, "region.joinnup.R"))
source(file.path(base_dir, "region.riskassess_v3.R"))
source(file.path(base_dir, "region.invasion_v4.R"))
source(file.path(base_dir, "linkNodesToCountry.R"))
source(file.path(base_dir, "Get_Nhood_Size.R"))
source(file.path(base_dir, "get_wavespeed.R"))
source(file.path(base_dir, "Sample_Nhood.R"))
source(file.path(base_dir, "SolveSpread_FP.R"))
source(file.path(base_dir, "cat_pl.R"))
source(file.path(base_dir, "print_pl.R"))
source(file.path(base_dir, "create_geography.R"))
Rprof("profiling.out")  # Start profiling
set.seed(1000 * batch_id)
ceiling(rand()*5)
ceiling(runif()*5)
ceiling(runif*5)
runif()
runif?
?runif
ceiling(runif(1)*5)
ceiling(runif(1)*5)
ceiling(runif(1)*5)
rztpois_custom <- function(n, lambda) {
probs <- dpois(1:100, lambda)
probs <- probs / sum(probs)  # normalize (since truncated at 0)
sample(1:100, size = n, replace = TRUE, prob = probs)
}
# SAMPLE location coordinates relative to origin
# A homogeneous spatial Poisson point process given focal field at origin
# 1 sample N points per area
# N=rpois(n=1,lambda=host_summary_stats$density*(nhood_size^2)*pi)
rztpois_custom(n = 1, lambda = 3)
rztpois_custom <- function(n, lambda) {
probs <- dpois(1:100, lambda)
probs <- probs / sum(probs)  # normalize (since truncated at 0)
sample(1:100, size = n, replace = TRUE, prob = probs)
}
# SAMPLE location coordinates relative to origin
# A homogeneous spatial Poisson point process given focal field at origin
# 1 sample N points per area
# N=rpois(n=1,lambda=host_summary_stats$density*(nhood_size^2)*pi)
rztpois_custom(n = 1, lambda = 3)
rztpois_custom <- function(n, lambda) {
probs <- dpois(1:100, lambda)
probs <- probs / sum(probs)  # normalize (since truncated at 0)
sample(1:100, size = n, replace = TRUE, prob = probs)
}
# SAMPLE location coordinates relative to origin
# A homogeneous spatial Poisson point process given focal field at origin
# 1 sample N points per area
# N=rpois(n=1,lambda=host_summary_stats$density*(nhood_size^2)*pi)
rztpois_custom(n = 1, lambda = 3)
rztpois_custom <- function(n, lambda) {
probs <- dpois(1:100, lambda)
probs <- probs / sum(probs)  # normalize (since truncated at 0)
sample(1:100, size = n, replace = TRUE, prob = probs)
}
# SAMPLE location coordinates relative to origin
# A homogeneous spatial Poisson point process given focal field at origin
# 1 sample N points per area
# N=rpois(n=1,lambda=host_summary_stats$density*(nhood_size^2)*pi)
rztpois_custom(n = 1, lambda = 3)
rm(list=ls())
######################################
sysname <- Sys.info()[["sysname"]]
rm(list=setdiff(ls(), "sysname"))
if (sysname == "Windows") {
base_dir <- "C:/Users/ruair/Desktop/dynamic_EpiPv/R"
} else {
base_dir <- "~/big_space/rd501/EpiPV_dyn"
}
args = commandArgs(trailingOnly=TRUE)
batch_id=as.integer(args[1])
library(parallel)
#setwd("C:/Users/ruair/Desktop/dynamic_EpiPv/R")
source(file.path(base_dir,'calculate_epidemic_probability_dyn.r'))
source(file.path(base_dir,'calculate_epidemic_probability_dyn_v4.r'))
source(file.path(base_dir,'solveInoculumStatesBP_dyn.r'))
set.seed(1000*batch_id)
batch_id
batch_id=1
set.seed(1000*batch_id)
print(paste('setting','set.seed(1000 *',batch_id,')'))
cbsi_virus_parameters=c(0.638,0.056,0.807)
names(cbsi_virus_parameters)=c("alpha h^-1","beta h^-1","mu h^-1")
cbsi_local_parameters=c(0.45,1/28,0*1/365,1/14,0*1/14)
names(cbsi_local_parameters)=c("theta d^-1","r d^-1","h d^-1","b d^-1","nu d^-1")
wf_dat_13=read.table('Population_2013_2014_planting_day_1.txt', sep = "\t", header = FALSE, dec =".")
library(parallel)
#setwd("C:/Users/ruair/Desktop/dynamic_EpiPv/R")
source(file.path(base_dir,'calculate_epidemic_probability_dyn.r'))
source(file.path(base_dir,'calculate_epidemic_probability_dyn_v4.r'))
source(file.path(base_dir,'solveInoculumStatesBP_dyn.r'))
set.seed(1000*batch_id)
print(paste('setting','set.seed(1000 *',batch_id,')'))
cbsi_virus_parameters=c(0.638,0.056,0.807)
names(cbsi_virus_parameters)=c("alpha h^-1","beta h^-1","mu h^-1")
cbsi_local_parameters=c(0.45,1/28,0*1/365,1/14,0*1/14)
names(cbsi_local_parameters)=c("theta d^-1","r d^-1","h d^-1","b d^-1","nu d^-1")
wf_dat_13=read.table(file.path(base_dir,'Population_2013_2014_planting_day_1.txt'), sep = "\t", header = FALSE, dec =".")
insect_data_list <- lapply(seq_len(nrow(wf_dat_13)), function(i) as.numeric(wf_dat_13[i, ]))
class(insect_data_list)
insect_data_list[[1]]
class(insect_data_list[[1]])
num_in_batch=10
((batch_id*num_in_batch)+1):((batch_id+1)*num_in_batch)
length(insect_data_list)
batch_indices <- ((batch_id*num_in_batch)+1):((batch_id+1)*num_in_batch)
batch_indices_trunc=min(batch_indices,length(insect_data_list))
batch_indices_trunc
batch_indices[batch_indices<=length(insect_data_list)]
batch_id=180
batch_indices <- ((batch_id*num_in_batch)+1):((batch_id+1)*num_in_batch)
batch_indices_trunc=batch_indices[batch_indices<=length(insect_data_list)]
batch_indices_trunc
batch_id=177
batch_indices <- ((batch_id*num_in_batch)+1):((batch_id+1)*num_in_batch)
batch_indices_trunc=batch_indices[batch_indices<=length(insect_data_list)]
batch_indices_trunc
batch_id=1
batch_indices <- ((batch_id*num_in_batch)+1):((batch_id+1)*num_in_batch)
batch_indices_trunc=batch_indices[batch_indices<=length(insect_data_list)]
batch_indices_trunc
nrow(insect_data_list)
length(insect_data_list)
length(insect_data_list)/10
length(insect_data_list)/5
batch_id=354
num_in_batch=5
batch_indices <- ((batch_id*num_in_batch)+1):((batch_id+1)*num_in_batch)
batch_indices_trunc=batch_indices[batch_indices<=length(insect_data_list)]
batch_indices_trunc
batch_indices[jj]
jj=1
batch_indices[jj]
insect_data_list[batch_indices[jj],],
insect_data_list[batch_indices[jj],]
insect_data_list[batch_indices[jj]]
insect_data_list[1]
class(insect_data_list[1])
numeric(insect_data_list[1])
as.numeric(insect_data_list[1])
as.vector(insect_data_list[1])
class(as.vector(insect_data_list[1]))
class(insect_data_list[[1]])
insect_data_list[[1]]
sprintf("results_batch_%03d.rds", batch_id)
hmm=readRDS("results_batch_0.rds")
hmm=readRDS("results_batch_000.rds")
base_dir
hmm=readRDS(file.path(base_dir,"results_batch_000.rds"))
dim(hmm)
hmm
batch_id
sprintf("results_batch_%03d.rds", batch_id)
sprintf("results_batch_%03d.rds", 1354)
sprintf("results_batch_", 1354,".rds")
sprintf("results_batch_%d.rds", 1354)
batch_id
library("rstantools")
install.packages("rstantools")
library("rstantools")
rstan_create_package(path = 'EpiPvr')
getwd()
setwd("C:/Users/ruair/Documents/EpiPvr")
if ("package:EpiPvr" %in% search()) {
detach("package:EpiPvr", unload = TRUE, character.only = TRUE)
}
devtools::clean_vignettes()
devtools::build()
